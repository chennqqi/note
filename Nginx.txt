
nginx

Nginx is a free, open-source, high-performance HTTP server and reverse proxy, as well as an IMAP/POP3 proxy server. Igor Sysoev started development of Nginx in 2002, with the first public release in 2004. Nginx now hosts nearly 7.67% (35.5M) of all domains worldwide.

Nginx is known for its high performance, stability, rich feature set, simple configuration, and low resource consumption.

Nginx is one of a handful of servers written to address the C10K problem. Unlike traditional servers, Nginx doesn't rely on threads to handle requests. Instead it uses a much more scalable event-driven (asynchronous) architecture. This architecture uses small, but more importantly, predictable amounts of memory under load.
Even if you don't expect to handle thousands of simultaneous requests, you can still benefit from Nginx's high-performance and small memory footprint. Nginx scales in all directions: from the smallest VPS all the way up to clusters of servers.

Nginx powers several high-visibility sites, such as WordPress, Hulu, Github, Ohloh, SourceForge, WhitePages and TorrentReactor.


功能：
web服务器
web reverse proxy
smtp reverse proxy

LNMP fastcgi,    lighttpd  (GNU, GUI, Gnome)


LNMP (cache, apc)
Corosync + ningx


Installing the nginx

yum install gcc openssl-devel pcre-devel zlib-devel 

# groupadd -r nginx
# useradd -r -g nginx -s /bin/false -M nginx

./configure \
  --prefix=/usr \
  --sbin-path=/usr/sbin/nginx \
  --conf-path=/etc/nginx/nginx.conf \
  --error-log-path=/var/log/nginx/error.log \
  --http-log-path=/var/log/nginx/access.log \
  --pid-path=/var/run/nginx/nginx.pid  \
  --lock-path=/var/lock/nginx.lock \
  --user=nginx \
  --group=nginx \
  --with-http_ssl_module \
  --with-http_flv_module \
  --with-http_stub_status_module \
  --with-http_gzip_static_module \
  --http-client-body-temp-path=/var/tmp/nginx/client/ \
  --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
  --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
  --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
  --http-scgi-temp-path=/var/tmp/nginx/scgi \
  --with-pcre
  
/usr/html


make && make install

关于配置选项的简单说明： 

--prefix=<path> - The path relative to which all other Nginx paths will resolve. If not specified, defaults to /usr/local/nginx.

--sbin-path=<path> - The path to the nginx executable. Only used for installation. If not specified defaults to <prefix>/sbin/nginx.

--conf-path=<path> - The default location of nginx.conf if no -c parameter is provided. If not provided, defaults to <prefix>/conf/nginx.conf. 

--pid-path=<path> - The path to nginx.pid, if not set via the "pid" directive in nginx.conf. If not provided, defaults to <prefix>/logs/nginx.pid. 

--error-log-path=<path> - The location of the error log if not set via the "error_log" in nginx.conf. If not set, defaults to <prefix>/logs/error.log.

--http-log-path=<path> - The location of the access log if not set via the "access_log" directive in nginx.conf. If not set, defaults to <prefix>/logs/access.log.

--user=<user> - The default user that nginx will run as if not set in nginx.conf via the "user" directive. If not set, defaults to "nobody".

--group=<group> - The default group that nginx will run under if not set via the "user" directive in nginx.conf. If not set defaults to "nobody". 

--with-http_ssl_module - Enable ngx_http_ssl_module. Enables SSL support and the ability to handle HTTPS requests. Requires OpenSSL. On Debian, this is libssl-dev.

--with-http_flv_module - Enable ngx_http_flv_module 

--http-client-body-temp-path=PATH - Set path to the http client request body temporary files. If not set, defaults to <prefix>/client_body_temp 

--http-proxy-temp-path=PATH - Set path to the http proxy temporary files. If not set, defaults to <prefix>/proxy_temp

--http-fastcgi-temp-path=PATH - Set path to the http fastcgi temporary files. If not set, defaults to <prefix>/fastcgi_temp 


--lock-path=<path> - The path to the nginx.lock file. If not provided, defaults to <prefix>/logs/nginx.lock. 


Red Hat Nginx Init Script Should work on RHEL, Fedora, CentOS. Tested on CentOS 5. 

Save this file as /etc/init.d/nginx 

http {
  server {
    location {
    }
    location
    {
    }
  }  
  server {
  }


}




























vim /etc/rc.d/init.d/nginx




#!/bin/sh
#
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15 
# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /etc/nginx/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /var/run/nginx.pid
 
# Source function library.
. /etc/rc.d/init.d/functions
 
# Source networking configuration.
. /etc/sysconfig/network
 
# Check that networking is up.
[ "$NETWORKING" = "no" ] && exit 0
 
nginx="/usr/sbin/nginx"
prog=$(basename $nginx)
 
NGINX_CONF_FILE="/etc/nginx/nginx.conf"
 
[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx
 
lockfile=/var/lock/subsys/nginx
 
make_dirs() {
   # make required directories
   user=`nginx -V 2>&1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
   options=`$nginx -V 2>&1 | grep 'configure arguments:'`
   for opt in $options; do
       if [ `echo $opt | grep '.*-temp-path'` ]; then
           value=`echo $opt | cut -d "=" -f 2`
           if [ ! -d "$value" ]; then
               # echo "creating" $value
               mkdir -p $value && chown -R $user $value
           fi
       fi
   done
}
 
start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    make_dirs
    echo -n $"Starting $prog: "
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] && touch $lockfile
    return $retval
}
 
stop() {
    echo -n $"Stopping $prog: "
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] && rm -f $lockfile
    return $retval
}
 
restart() {
    configtest || return $?
    stop
    sleep 1
    start
}
 
reload() {
    configtest || return $?
    echo -n $"Reloading $prog: "
    killproc $nginx -HUP
    RETVAL=$?
    echo
}
 
force_reload() {
    restart
}
 
configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}
 
rh_status() {
    status $prog
}
 
rh_status_q() {
    rh_status >/dev/null 2>&1
}
 
case "$1" in
    start)
        rh_status_q && exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"
        exit 2
esac
[root@localhost nginx]# chkconfig --add nginx
[root@localhost nginx]# chkconfig nginx on





用户限制：
 auth_basic "Restricted Area...";
 auth_basic_user_file /etc/nginx/.users;
1.yum -y insatll http 
2.htpasswd -cm  /etc/nginx/.users tom
3. htpasswd -m  /etc/nginx/.users  wang
 
web service
 	nginx：web server（static contents）web reverse proxy（http）,cache
 	varnish,squid (cache),web,http headers 
 	haproxy:基于应用层和tcp层的反向代理，http revers proxy
 	keeplived：HA
 	ats：apache traffic server

可扩展的web架构
 	MogileFS：图片存储
 	NoSQL（MongoDB）

 Nginx：engine x
 	apache：MPM（prefork，event）
 	c10k，lighttpd，nginx

 	http protcol
 		request --> respone
 		请求报文
 			<method><URL><version>
 			<headers>


 			<body>
 		响应报文
 			<version><status code> <reason phrase>
 			<headers>


 			<body>
 		响应码
 			1XX
 			2XX:成功响应码
 				200
 			3XX：重定向
 				301
 				302
 				304
 			4XX:客户端错误
 			5XX：服务器端错误

LNMP:php必须工作与fpm模式

stateless：无状态
	web page：web object
	http：80/tcp
	 	tcp 三次握手，四次断开

	 	keepalive：
	 		时间：timeout
	 		数量：
	 	
	 	cookie：
	 		session 保存
	 			session 绑定
	 				反均衡
	 				session无高可用
	 			session复制
	 				服务器资源消耗过大
	 				网络资源
	 			session服务器
	 				服务器自身的高可用

	 		lvs session绑定
	 			sh算法：基于源IP做绑定
	 			persitent connection：持久连接
	 			cookie均衡：Tengine

web I/O模型
	同步
		阻塞
		非阻塞
	I/O复用
		select(),
		poll()
		prefork:基于select()

	时间通知
	异步

	mmap：数据以磁盘直接以页面方式映射进内存中

（并发编程）处理并发用户请求：
		单进程模型：串行方式模式
		多进程模型：prefox，一个进程响应一个用户请求，并发使用多个进程实现
		多线程模型：worker，一个进程生成多个线程，一个线程响应一个用户请求；并发使用多个线程实现：n进程，n*m个线程
		线程（事件）模型：event。一个线程响应多个用户请求，基于事件驱动机制来维持多个用户请求

nginx的特性：
	基本功能：
		实现与服务静态文件（静态资源的web服务器），能缓存打开的文件描述符
		反向代理服务器，缓存、负载均衡、健康状态检测
		支持FastCGI
		模块化机制，非DSO机制，支持多种过滤器gzip，SSI和图像的模块完成图形大小调整等
		支持SSL

	扩展功能：
		基于名称和IP做虚拟主机
		支持keeplive
		支持平滑配置更新或程序版本升级
		定制访问日志，支持使用日志缓存以提高性能
		支持URL rewrite
		支持路径别名
		支持基于IP及用户的认证：
		支持速率限制，并发数限制等

	nginx的基本架构
		一个master 生成一个或多个worker
		事件驱动：kqueue，epoll，/dev/poll
			消息通知：select，poll，rt rignals
		支持sendfile，sendfile64
		文件AIO（异步I/O）
		支持mmap

	nginx：非阻塞、事件驱动，一个master多个worker，一个worker响应多个用户请求


	比cpu的核心进程少一个即可以

nginx的模块类别
	核心模块
	标准http模块
	可选的http模块
	邮件模块
	第三方扩展模块


安装方法：
	编译安装
	rpm包安装
		epel源

Nginx的配置文件
	main配置段
	http{

	}
	mail{

	}

	配置参数需要以分号结尾，语法格式：
		参数名 值1[值2...];

		还支持使用变量
			模块内置变量
			用户自定义变量
				set var_name value

Nginx基本核心配置的类别
	用于调试、定位问题
	正常运行的必备配置
	优化性能的配置
	事件类的配置

worker进程应该以普通用户身份运行。nginx用户，nginx组
	http的方法：GET，HEAD，POST,PUT,DELETE OPTIONS TRACE

配置文件
	正常运行的必备配置：
		1.user username [groupname]；
		以那个用户身份运行,以在configure指定的用户为准
		2.pid /path/to/pid_filename;
		指定nginx的pid文件
		3.worker_rlimit_nofile #;
		指定一个worker进程所能够打开的句柄数
		4.worker_rlimit_sigpending #;
		设定每个用户能够发往worker进程的信号的数量；

	优化性能相关的配置
		1.worker_procrsses #
			work进程的个数 ，通常其数值应该为cpu的物理核心数减1
		2.worker_cpu_affinity cpumask ....;
		0000
		0001
		0010
		0100
		1000
		对应位上使用cpu，要做单独绑定
		work_procrsses 6
		worker_cpu_affinity 00000001 00000010 00000100 00001000
		00010000 00100000
		
		3.ssl_engine device;
		在存在ssl硬件加速器的服务器上，指定所使用的ssl硬件加速设备
		4.timer_resolution t
		每次内核事件调用返回时，都会使用gettimeday（）来更新nginx缓存时钟；timer_resolution用于定义每隔多久才会由gettimeday（）更新一次缓存时钟；x86-64系统上，gettimeday()代价已经很小，可以忽略此配置
		5.worker_priority nice;
		 -20到19之间的值，值越小越优先调用

	跟事件相关的配置
		1.accept_mutex [on|off]
		 是否打开nginx的负载均衡锁；此锁能够让多个worker进行轮流地、序列化地与新的客户端建立连接；而通常当一个worker进程的负载达到其上限的7/8，master就尽可能不将请求调度至worker
		2.lock_file /path/to/lock_file；
		锁文件
		3.accept_mutex_delay #ms
		 使用accept锁以后，只有一个worker能取得锁，一个worker进程为取得accept锁的等待时长，即用户建立等待的时间，如果某worker进程在某次试图取得锁时失败了，至少要等待#ms才能在一次请求锁
		4.multi_accept on|off
		是否允许一次性地响应多个用户请求，默认为off
		5.use [epoll|rtsig|select|poll]
		指定使用那种模型,建议让nginx自动选择
		6.worker_commections # 
		每个worker能够并发响应的最大请求数，如果为代理服务器的话，worker_rlimit_nofile=worker_commections*2

	用于调试、定位问题：只调试nginx时使用
		1.daemon [on|off];
		 关闭提供守护进程的模式，是否让nignx运行于后台；调试时应该为off，使得所有信息直接输出在控制台，默认为on
		2.master_process on|off
		 是否以master/worker模式运行nginx，默认为on，调试时可以设置为off以方便追踪
		3.error_log /path/to/error_log level
		错误日志文件及其级别，调试时可以使用debug级别，但要求在编译时必须使用--with-debug启用debug功能，默认通常为error级别

nginx的http web功能
	必须使用虚拟机来配置站点:每个虚拟主机使用一个server{}段来配置
	   server{

	   }
	非虚拟主机的配置和公共选项，需要定义在server之外，http之内
		http{
			directive value;
			....

			server{

			}
			server{

			}
			......
		}

	1.server{}
	  定义一个虚拟主机：nginx支持使用基于主机名或IP的虚拟主机
	2.listen
	   listen address[:port]
	   listen prot
	   listen unix:socket

	   default_server:定义此server为http中默认的server；如果所有的server中任何一个listen使用此参数，那么第一个server即为默认server

	   rcvbuf=SIZE：接收缓存大小
	   sndbuf=SIZE: 发送缓存大小
	   ssl：https server：必须以ssl连接
	3.server_name [...];
	   server_name可以跟多个主机名，名称可以使用通配符和正则表达式（通常以~开头）：当nginx收到一个请求时，会取出其首部的server的值，而后跟众server_name进行比较：比较方式
	   	 (1) 先做精确匹配
	   	 (2) 左侧通配符匹配
	   	 (3) 右侧通配符匹配
	   	 (4) 正则表达式匹配
	4.server_name_hash_bucket_size 32|64|128
	   为了实现快速主机查找，nginx使用hash表来保存主机名
	5.location [ =|~|~*|^~] uri { ... }
	  location @name { ... }
	    功能：允许根据用户请求的URI来匹配指定的各location以进行访问配置；匹配到时，将被location块中的配置所处理
	    =：精确匹配
	    ~：正则表达式模式匹配，匹配时区分字符大小写
	    ~*：正则表达式模式匹配，匹配时忽略字符大小写
	    ^~:只需要前半部分与uri匹配即可，不检查正则表达式

	    匹配优先级：
	    	字符字面量最精确匹配、正则表达式检索（由多个时，由第一个匹配到的所处理），按字符字面量

文件路径定义
	1.root path
		设置web资源路径，用于指定请求的根文档目录，从跟开始匹配
		root：root/URI
	2.alias path
		指定路径别名，只能用于location中，从最后一个/开始匹配
		alias：alias/
	3.index file....
	     定义默认页面，可以跟多个值。自左向右匹配
	4.error_page code ... [=[response]] uri
		当对于某个请求发回错误时，如果匹配上了error_page指令中设定的code，则从定向至新的新URI中 
		错误重定向
	5.try_files path1 [path2...] uri;
		自左向右尝试读取有path所指定路径，在第一找到即停止并返回，如果所有path均不存在，则返回最后一个uri
	location ~* ^/document/(.*)${
		root /www/htdocs
		try_files $uri /docu/$1 /temp.html
	}

	http://www.wangfeng7399.com/documents/a.html
	http://www.wangfeng7399.com/docu/a.html
	http://www.wangfeng7399.com/temp.html

网络连接相关的设置
	1.keepalive_timeout time;
		保持连接的超时时长，默认为75s
	2.keepalive_requests n
		在一次长连接上允许承载的最大请求数
	3.keepalive_disable [msie6|safari |none]
		对指定的浏览器禁止使用长连接
	4.tcp_nodelay on|off
		对keepalive连接是否使用tcp_nodelay选项
	5.client_header_timeout time
		读取http请求首部的超时时长
	6.client_body_timeout time
		读取http请求包体的超时时间
	7.save_timeout time
		发送响应的超时时长

对客户端请求的限制：
	1.limit_except method ...{ ... }
	    指定范围之外的其他方法的访问控制，只能用于location中
	2.client_max_body_size size
	     http请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的Content-Length来检查，以避免无用的传输
	3.limit_rate speed
		 限制客户端每秒传输的字节数，默认为0，表示没有限制
	4.limit_rate_after time
		nginx向客户端发送响应报文时，如果时长超过了此处指定的时长，则后续的发送过程开始限速

文件操作的优化
	1.sendfile on|off
		是否启用sendfile功能
	2.aio on|off
		是否启用aio功能
	3.open_file_cache man=N [incative=time]|off
		是否打开文件缓存功能
		max：用于缓存条目的最大值，允许打开的缓存条目最大数，当满两类以后将根据LRU（最小最少连接数）算法进行置换
		inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除；通常默认为60s

		缓存的信息包括：
			文件句柄、文件大小和上次修改时间
			已经打开的目录结构：
			没有找到或没有访问权限的信息
	4.open_file_cache_errors on|off
		是否缓存文件找不到或没有权限访问等相关信息
	5.open_file_cache_valid time
		多长时间检查一次缓存中的条目是否超出非活动时长，默认为60s
	6.open_file_cache_min_use #
		在inactive指定的时长内被访问超过此处指定的次数时，才不会被删除

对客户端请求的特殊处理
	1.ignore_invalid_headers on|off
		是否忽略不合法的http首部，默认为on，off意味着请求首部中出现不合规的首部将拒绝响应，只能用于server和http
	2.log_not_found on|off
		用户访问的文件不存在时，是否将其记录到错误日志中
	3.resolver address：
	 	指定nginx使用的dns服务器地址
	 4.resolve timeout
	 	指定DNS解析超时时长，默认为30s
	 5.server_tokens on|off
	 	是否在错误页面中显示nginx的版本号

http核心模块的内置变量：
	$uri:当前请求的uri，不带参数
	$request_uri：请求的uri，带完整参数
	$host：http请求报文中host首部；如果请求中没有host首部，则以处理此请求的主机的主机名代替
	$hostname：nginx服务运行所在主机的主机名
	$remote_addr：客户端IP
	$remote_port: 客户端port
	$remote_user：使用用户认证时客户端用户输入的用户名
	$request_filename：用户请求中的URI经过本地root或alias转换后映射的本地的文件路径
	$request_method：请求方法
	$server_addr：服务器地址
	$server_name: 服务器名称
	$server_port：服务器端口
	$server_protocol：服务器向客户端发送响应时的协议，如http/1.1，http/1.0
	$scheme:在请求中使用的scheme 映射协议本身的协议
	$http_HEADER:匹配请求报文中指定的HEADER，$http_host匹配请求报文中的host首部
	$sent_http_HEADER:匹配响应报文中指定的HERDER，例如$http_content_type匹配相应报文中的content-type首部
	$document_root：当前请求映射到的root配置


配置使用nginx
	1.nginx虚拟主机
		server{
			listen
			server_name
			root
		}
	2.访问控制access模块
		allow
		deny
		至上而下依次认证，默认为通过
	3.基于用户认证 
		location /admin/ {
			root
			auth_basic "" 标题
			auth_basic_user_file "" 密码的存放位置
		}
		使用htpasswd创建密码
	4，建立下载站点autoindex下载列表
		location /download/{
			root
			autoindex on
		}
	5.防盗链
		(1)定义和规定额引用
		valid_referers none |blocked |server_names|string ...
		(2)判断不合规的引用
		if ($invaild_referer) {
			rewrite ^/.*$ http://www.a.com/403.html
		}
	6.URL rewrite
		rewrite regex replacement [flag];

		location / {
			root
			rewrite ^/imgages/(.*)$ /imgs/$1
		}
		
		flag:标志位
			 last:一旦被当前规则匹配并重写后立即停止检查后续饿的其他rewrite的规则，而后通过重写后的规则重新发起请求
			 break：一旦被当前规则匹配并重写后立即停止检查后续饿的其他rewrite的规则，而后继续由nginx进行后续的操作
			 redirect：返回302临时重定向代码
			 permanent：返回301永久重定向

		nginx最多循环10次，超出之后返回500错误

			括号不需要转移
		注意：一般将rewrite写在location中时都使用break标志，或者将rewrite卸载if上下文中

		rewrite_log on|off
			是否将重写过程记录在错误日志中，默认为notice级别；默认为off

		return code：
			用于结束rewrite规则，并且为客户返回状态码：可以使用的状态码有204，400，402-406，500-504等
		if (condition) {

		}
			用于检测条件是否成立
	7.状态页
		location{
			stub-status on
		}

			当下处于活动状态的总数

			接受的总数 已经建立和处理总数 请求的总数
			
			正在接受的并发请求个数，正在读取的个数或发往客户端的 ，长连接中的处于活动状态的值
	8.压缩：
		gzip
		  gzip on|off
		  gzip_buffer 使用的缓存大小
		  gzip_comp_level 压缩的级别
		  gzip_disable 不压缩的类型或浏览器
		  gzip_min_length 最少压缩的大小
		  gzip_http_version 压缩完成以后发送http的版本
		  gzip_types：只压缩的格式




Configuration directive:

listen

syntax: listen address:port [ default [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ] 

default: listen 80

context: server

The listen directive specifies the address and port accepted by the enclosing server {...} block. It is possible to specify only an address, only a port, or a server name as the address.

listen 127.0.0.1:8000;
listen 127.0.0.1;
listen 8000;
listen *:8000;
listen localhost:8000;


location / {

}

location = / {


}

/a/bc/d.html

/bbs/a.html
/bbs/a/b.html


http://www.a.org/bbs/abc


location 

syntax: location [=|~|~*|^~|@] /uri/ { ... }

default: no

context: server

This directive allows different configurations depending on the URI. It can be configured using both literal strings and regular expressions. To use regular expressions, you must use a prefix:

   1. "~" for case sensitive matching
   2. "~*" for case insensitive matching 

To determine which location directive matches a particular query, the literal strings are checked first. Literal strings match the beginning portion of the query - the most specific match will be used. Afterwards, regular expressions are checked in the order defined in the configuration file. The first regular expression to match the query will stop the search. If no regular expression matches are found, the result from the literal string search is used. 

It is possible to disable regular expression checks after literal string matching by using "^~" prefix. If most specific match literal location have this prefix - regular expressions aren't checked. 


By using "=" prefix on may define exact match between URI and location. On match search stops immediately as further search has no sense. E.g. if the request "/" occurs frequently, using "location = /" will speed up processing of this request a bit as search will stop after first comparison.



On exact match with literal location without "=" or "^~" prefixes search is also immediately terminated.

To summarize, the order in which directives are checked is as follows:

   1. Directives with the "=" prefix that match the query exactly. If found, searching stops.
   2. All remaining directives with conventional strings. If this match used the "^~" prefix, searching stops.
   3. Regular expressions, in the order they are defined in the configuration file.
   4. If #3 yielded a match, that result is used. Otherwise, the match from #2 is used. 

It is important to know that nginx does the comparison against decoded URIs. For example, if you wish to match "/images/%20/test", then you must use "/images/ /test" to determine the location.

Example:

location  = / {
  # matches the query / only.
  [ configuration A ] 
}
location  / {
  # matches any query, since all queries begin with /, but regular
  # expressions and any longer conventional blocks will be
  # matched first.
  [ configuration B ] 
}
location ^~ /images/ {
  # matches any query beginning with /images/ and halts searching,
  # so regular expressions will not be checked.
  [ configuration C ] 
}
location ~* \.(gif|jpg|jpeg)$ {
  # matches any request ending in gif, jpg, or jpeg. However, all
  # requests to the /images/ directory will be handled by
  # Configuration C.   
  [ configuration D ] 
}

Example requests:
    * / -> configuration A
  * /a.html
    * /documents/document.html -> configuration B
    * /images/1.gif -> configuration C
    * /documents/1.jpg -> configuration D 

Note that you could define these 4 configurations in any order and the results would remain the same. While nested locations are allowed by the configuration file parser, their use is discouraged and may produce unexpected results.

The prefix "@" specifies a named location. Such locations are not used during normal processing of requests, they are intended only to process internally redirected requests



root

syntax: root path

default: root html

context: http, server, location, if in location root specifies the document root for the requests. For example, with this configuration

location  /i/ {
  root  /spool/w3;
}

/i/c/d.html

/spool/w3/i/c/d.html



A request for "/i/top.gif" will return the file "/spool/w3/i/top.gif". You can use variables in the argument.

note: Keep in mind that the root will still append the directory to the request so that a request for "/i/top.gif" will not look in "/spool/w3/top.gif" like might happen in an Apache-like alias configuration where the location match itself is dropped. Use the alias directive to achieve the Apache-like functionality. 




server

syntax: server {...}

default: no

context: http

Directive assigns configuration for the virtual server.

There is no separation of IP and name-based (the Host header of the request) servers.

Instead, the directive listen is used to describe all addresses and ports on which incoming connections can occur, and in directive server_name indicate all names of the server. 


alias

DocumentRoot /web/htdocs

URI: /a/b.html
URI: /bbs


syntax: alias file-path|directory-path;

default: no

context: location

This directive assigns a path to be used for the indicated location. Note that it may look similar to the root directive, but the document root doesn't change, just the file system path used for the request.

For example:

location / {
  root /spool/w3;
}


location  /bbs/ {
  alias  /spool/bbs/;
}

URI: /i/a.html  --> /spool/w3/images/a.html

location = /bbs/a.html {
    root /web/vhosts;
  alias /web/vhosts/bbs/a.html;
}
/web/vhosts/bbs/


The request "/i/top.gif" will return the file "/spool/w3/images/top.gif".

Alias can also be used in a regex specified location.

For example:

location ~ ^/download/(.*)$ {
  alias /home/website/files/$1;
}

The request "/download/book.pdf" will return the file "/home/website/files/book.pdf"

It is possible to use variables in the replacement path. 


index

syntax: index file-path [file-path [ ... ] ];

default: no

context: server, location 

Sets the default file to serve if no file is specified in the URL. Multiple files can be specified. If the first file isn't found, the second will be used and so on. 


Options Indexes FollowSynlinks




autoindex module:

This module provides automatic directory listings.

The request only reaches the ngx_http_autoindex_module when the ngx_http_index_module did not find an index file.

Example configuration

location  /  {
  autoindex  on;
}

autoindex

syntax: autoindex [ on|off ]

default: autoindex off

context: http, server, location

Enables or disables the automatic directory listing.


autoindex_exact_size

syntax: autoindex_exact_size [ on|off ]

default: autoindex_exact_size on

context: http, server, location

Defines how to represent file sizes in the directory listing -- either accurately (in bytes), or rounded (KB, MB or GB).


autoindex_localtime

syntax: autoindex_localtime [ on|off ]

default: autoindex_localtime off

context: http, server, location

Enables showing file times as local time. Default is "off" (GMT time). 




AccessModule
This module provides a simple host-based access control.

Module nginx_http_access_module makes it possible to control access for specific IP-addresses of clients.

Access rules are checked according to the order of their declaration. The first rule that matches a particular address or set of addresses is the one that is obeyed.

Example configuration:

location / {
  deny    192.168.1.1;
  allow   192.168.1.0/24;
  allow   10.1.0.0/16;
  deny    all;
}

In this example access is granted to networks 10.1.1.0/16 and 192.168.1.0/24 with the exception of address 192.168.1.1, which is denied access together with all other addresses as defined by the deny all rule that is matched last in this location block.

Note that the order of the deny/allow is of the utmost importance.


allow

syntax: allow [ address | CIDR | all ]

default: no

context: http, server, location, limit_except

Directive grants access for the network or addresses indicated.


deny

syntax: deny [ address | CIDR | all ]

default: no

context: http, server, location, limit_except

Directive forbids access for the network or addresses indicated. 






Virtual Hosts Examples 

http {
  server {
    listen          80;
    server_name     www.a.com;
    access_log      logs/a.access.log main;
 
    index index.html;
    root  /var/www/a.com/htdocs;
  }
 
  server {
    listen          8080;
    server_name     www.b.com;
    access_log      logs/b.access.log main;
 
    index index.html;
    root  /var/www/b.com/htdocs;
  }
}



www.magedu.com   /www/magedu
dz.magedu.com    /www/discuz





A Default Catchall Virtual Host 

http {
  server {
    listen          80 default;
    server_name     _;
    access_log      logs/default.access.log main;
 
    server_name_in_redirect  off;
 
    index index.html;
    root  /var/www/default/htdocs;
  }
}




/web/html








开启Nginx状态监控的功能：

location /nginx_status {
  stub_status on;
  access_log off;
}





stub_status
syntax: stub_status on

default: None

context: location

Enables the status handler in this location.

The stub status module reports status similar to mathopd's status page. It is plain text information like

Active connections: 291
server accepts handled requests
  16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106

active connections -- number of all open connections including connections to backends

server accepts handled requests -- nginx accepted 16630948 connections, handled 16630948 connections (no one was closed just it was accepted), and handles 31070465 requests (1.8 requests per connection)

reading -- nginx reads request header

writing -- nginx reads request body, processes request, or writes response to a client

waiting -- keep-alive connections, actually it is active - (reading + writing)

























启用基于用户的认证：
server {
  server_name www.magedu.com;
  . . .
  location / {
    auth_basic "Restricted";
    auth_basic_user_file /etc/nginx/.htpasswd;
    . . .
  }
  
  location ~ /\.ht {
        deny  all;
  }
  
}







What is FastCGI

FastCGI is a high-speed and scalable interface for communicating with the web server scripting language. FastCGI is supported by many scripting languages, including php, if it is compiled with the option - --enable-fastcgi. 

It is supported by most popular web servers, including Apache (mod_fastcgi and mod_fcgid), Zeus, nginx and lighttpd. The main advantage of FastCGI is isolating the dynamic language from the web server. The technology, among other things, allows you to run a web server and dynamic language for the different hosts, which improves scalability and also aids security without a significant loss of productivity. 

PHP-FPM works on with any web server that supports FastCGI.


Howto

Make sure libxml2 (and libxml2-devel) is installed, and libevent version is 1.4.12 or later.

for PHP 5.2.x: 

$ bzip2 -cd php-5.2.13.tar.bz2 | tar xf -
$ patch -d php-5.2.13 -p1 <php-fpm-0.6~5.2.patch
$ cd php-5.2.13
$ ./buildconf --force
$ ./configure --enable-fastcgi --with-fpm --with-libevent[=path] ...

autorun php-fpm: 

$ ln -s /usr/local/sbin/php-fpm /etc/init.d/php-fpm
$ /usr/sbin/update-rc.d -f php-fpm defaults


for PHP 5.3.x: 

$ cd php-5.3.x
$ svn co http://svn.php.net/repository/php/php-src/trunk/sapi/fpm sapi/fpm
$ ./buildconf --force
$ ./configure --enable-fpm ...your other configure options, etc...
$ make && make install
Edit /etc/php-fpm.conf 

Run php-fpm start (probably in your $PATH). Check logfile /var/log/php-fpm.log for details if needed.  
 



PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation with some additional features useful for sites of any size, especially busier sites.


for PHP 5.3.3

PHP-FPM is now included in PHP core as of PHP 5.3.3.   Make sure libxml2 (and libxml2-devel) is installed, and libevent version is 1.4.12 or later, and libiconv.

libevent

The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.

libevent is meant to replace the event loop found in event driven network servers. An application just needs to call event_dispatch() and then add or remove events dynamically without having to change the event loop.

Currently, libevent supports /dev/poll, kqueue(2), event ports, select(2), poll(2) and epoll(4). The internal event mechanism is completely independent of the exposed event API, and a simple update of libevent can provide new functionality without having to redesign the applications. As a result, Libevent allows for portable application development and provides the most scalable event notification mechanism available on an operating system. Libevent can also be used for multi-threaded applications. 

# tar zxvf libevent-1.4.14b-stable.tar.gz
# cd libevent-1.4.14b-stable
# ./configure
# make && make install
# make verify


libiconv

For historical reasons, international text is often encoded using a language or country dependent character encoding. With the advent of the internet and the frequent exchange of text across countries - even the viewing of a web page from a foreign country is a "text exchange" in this context -, conversions between these encodings have become important. They have also become a problem, because many characters which are present in one encoding are absent in many other encodings. To solve this mess, the Unicode encoding has been created. It is a super-encoding of all others and is therefore the default encoding for new text formats like XML.

Still, many computers still operate in locale with a traditional (limited) character encoding. Some programs, like mailers and web browsers, must be able to convert between a given text encoding and the user's encoding. Other programs internally store strings in Unicode, to facilitate internal processing, and need to convert between internal string representation (Unicode) and external string representation (a traditional encoding) when they are doing I/O. GNU libiconv is a conversion library for both kinds of applications. 

# tar zxvf libiconv-1.13.1.tar.gz
# cd libiconv-1.13.1
# ./configure
# make && make install




libmcrypt

MCrypt is a replacement for the old crypt() package and crypt(1) command, with extensions. It allows developers to use a wide range of encryption functions, without making drastic changes to their code. It allows users to encrypt files or data streams without having to be cryptographers. Above all, it allows you to have some really neat code on your machine. :)

The companion to MCrypt is Libmcrypt, which contains the actual encryption functions themselves, and provides a standardized mechanism for accessing them. 
# tar zxvf libmcrypt-2.5.8.tar.gz
# cd libmcrypt-2.5.8
# ./configure
# make && make install
# ldconfig -v
# cd libltdl
# ./configure --with-gmetad --enable-gexec --enable-ltdl-install
# make && make install




mhash

Mhash is a free (under GNU Lesser GPL) library which provides a uniform interface to a large number of hash algorithms. These algorithms can be used to compute checksums, message digests, and other signatures. 

# tar jxvf mhash-0.9.9.9.tar.bz2
# cd mhash-0.9.9.9 
# ./configure
# make && make install

# ln -sv /usr/local/lib/libmcrypt* /usr/lib/
# ln -sv /usr/local/lib/libmhash.* /usr/lib/


php-5.3.6

# tar jxvf php-5.3.6.tar.bz2
# cd jxvf php-5.3.6
# ./configure --prefix=/usr/local/php --with-mysql=/usr/local/mysql --with-openssl --enable-fpm --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib-dir --with-libxml-dir=/usr --enable-xml  --with-mhash --with-mcrypt  --with-config-file-path=/etc/php --with-config-file-scan-dir=/etc/php --with-bz2 --with-curl 


--with-iconv=/usr/local

# make ZEND_EXTRA_LIBS='-liconv'
# make install
# cp php.ini-production /usr/local/php/etc/php.ini
# cp sapi/fpm/init.d.php-fpm  /etc/rc.d/init.d/php-fpm
# 

启动fastcgi：
# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf 
# vim /usr/local/php/etc/php-fpm.conf
启用如下选项：
pm.max_children = 50
pm.start_servers = 5
pm.min_spare_servers = 2
pm.max_spare_servers = 8
pid = /var/run/php-fpm.pid


# 



编译php跟apache起工作：
./configure --prefix=/usr/local/php4httpd --with-mysql=/usr/local/mysql --with-openssl --with-apxs2=/usr/local/apache/bin/apxs --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib-dir --with-libxml-dir=/usr --enable-xml  --with-mhash --with-mcrypt --with-bz2 --with-curl











接下来整合nginx和php5

编辑/etc/nginx/nginx.conf，启用如下选项：
location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi_params;
        }
        
        
FastCGI Example

First thing, I recommend keeping all your typical FCGI settings in a single file and importing them.

For example you might have an /etc/nginx/fastcgi.conf (or /etc/nginx/fastcgi_params: installed by default on debian) file that looks like this:

#vim fastcgi_params
fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx;
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;
fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
fastcgi_param  REQUEST_URI        $request_uri;
fastcgi_param  DOCUMENT_URI       $document_uri;
fastcgi_param  DOCUMENT_ROOT      $document_root;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  REMOTE_PORT        $remote_port;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;


并在所支持的主页面格式中添加php格式的主页，类似如下：
location / {
            root   html;
            index  index.php index.html index.htm;
        }
        
而后重启nginx。
# service nginx restart





为FCGI设定缓存：
http {
  fastcgi_cache_path /www/cache levels=1:2
    keys_zone=fcgicache:10m
    inactive=5m;
  server {
    server_name wwww.magedu.com;
    ...
    location / {
      ...
      fastcgi_pass 127.0.0.1:9000;
      fastcgi_cache fcgicache;
      fastcgi_cache_valid 200 302 1h;
      fastcgi_cache_valid 301 1d;
      fastcgi_cache_valid any 1m;
      fastcgi_cache_min_uses 1;
      fastcgi_cache_use_stale error timeout invalid_header http_500;
    }
  }
}









xcache安装配置：
# tar xf xcache-1.3.2.tar.gz
# cd xcache-1.3.2
# /usr/local/php/bin/phpize
# ./configure --enable-xcache --with-php-config=/usr/local/php/bin/php-config
# make && make install

安装结束时，会出现类似如下行：
Installing shared extensions:     /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/

# cat xcache.ini >> /usr/local/php/lib/php.ini

接下来编辑/usr/local/php/lib/php.ini，找到zend_extension开头的行，修改为如下行：
zend_extension = /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/xcache.so

注意：如果php.ini文件中有多条zend_extension指令行，要确保此新增的行排在第一位。


各配置选项说明：
xcache.admin.user string
  auth name.
xcache.admin.pass string
  Should be md5($your_password), or empty to disable administration.
xcache.test string
  Turn on to enable testing functionals. It will be explained where the option is needed.
xcache.coredump_directory string
  Directory to save core dump on crash (SIGSEGV SIGABRT). Leave it empty to disable or something like "/tmp/phpcore/" to enable. Make sure it's writable by php (without checking open_basedir).
xcache.admin.enable_auth string
  Disable XCache builtin http authentication if you plan on handling authentication yourself. Be aware that any vhost users can set up admin page, if builtin http auth is disabled, they can access the page with out any authentication. So it is suggested that you disable mod_auth for XCache admin pages instead of disabling XCache builtin auth. This option is 1.2.x only since 1.2.1

xcache.cacher boolean
  Enable or disable opcode cacher. Not available if xcache.size is 0.
xcache.size int
  0 to disable, non 0 to enable. Check if your system mmap allows.
xcache.count int
  Specify how many chunks to split the cache. see SplittedCache
xcache.slots size
  Just a "slots" hint for hash, you can always store count(items) > slots. It can be (count(items) * n) where n is 0.2 to 1, or leave it as is. More slots means faster searching the cache but take more memory.
xcache.ttl seconds
  Ttl (Time To Live) value for the php entry (cached opcodes of a file), 0=forever.
xcache.gc_interval seconds
  Garbage collection interval.
xcache.var_size int
  xcache.var_count int
xcache.var_slots size
  Same as above, but for variable data.
xcache.var_ttl seconds
  Default ttl for variables api, xcache_(get|set|inc|dec) etc.
xcache.var_maxttl seconds
  A longer ttl when using variables api is limited to below max ttl.
xcache.var_gc_interval seconds
  Garbage collection interval for variables api.
xcache.readonly_protection boolean
  If ReadonlyProtection is turned on, it will be a bit slower, but much safer. This option isn't available for /dev/zero.
xcache.mmap_path string
  for *nix, xcache.mmap_path is a file path, not directory. for win32, xcache.mmap_path is anonymous map name, not a file path. Use something like "/tmp/xcache" if you want to turn on ReadonlyProtection, 2 group of php won't share the same /tmp/xcache.




LAMP

memcached

memcache




安装Memcache的PHP扩展

①安装PHP的memcache扩展

# tar xf memcache-2.2.5.tgz
# cd memcache-2.2.5
/usr/local/php/bin/phpize
# ./configure --with-php-config=/usr/local/php/bin/php-config --enable-memcache
# make && make install

上述安装完后会有类似这样的提示：

Installing shared extensions:     /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/

②编辑/usr/local/php/lib/php.ini，在“动态模块”相关的位置添加如下一行来载入memcache扩展：
extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/memcache.so


而后对memcached功能进行测试，在网站目录中建立测试页面test.php，添加如下内容：
<?php
  $mem = new Memcache;
  $mem->connect("127.0.0.1", 11211);
  $mem->set('mykey', 'Hello World', 0, 600);
  $val = $mem->get('mykey');
  echo "$val is from memcached server.";         
?>

如果有输出“Hello World is from memcached.”，则表明memcache已经能够正常工作。




使用libmemcached的客户端工具:

访问memcached的传统方法是使用基于perl语言开发的Cache::memcached模块，这个模块在大多数perl代码中都能良好的工作，但也有着众所周知的性能方面的问题。libMemcached则是基于C语言开发的开源的C/C++代码访问memcached的库文件，同是，它还提供了数个可以远程使用的memcached管理工具，如memcat, memping，memstat，memslap等。



编译安装libmemcached

# tar xf libmemcached-1.0.2.tar.gz 
# cd libmemcached-1.0.2
# ./configure 
# make && make install
# ldconfig



客户端工具
# memcat --servers=127.0.0.1:11211 mykey
# memping 
# memslap
# memstat










Secure your upload directory!!

Too many example configs fail to secure the "uploads" directory of the application. Remember that if someone can upload a file named xyz.php and the uploads dir is publically accessible then you have given the attacker an easy way to insert PHP onto your site...

So if your app has an upload dir "/images/" then insert if ($uri !~ "^/images/") before fastcgi_pass, as so:

location ~ \.php$ {
...
...
  if ($uri !~ "^/images/") {
    fastcgi_pass 127.0.0.1:9000;
  }
}


www.magedu.com/images/logo.jpg  --> http://img.magedu.com/images/logo.jpg


rewirte "/images/\(.*\.jpg\)"  http://img.magedu.com/images/$1












PDO_MYSQL

PDO_MYSQL is a driver that implements the PHP Data Objects (PDO) interface  to enable access from PHP to MySQL 3.x, 4.x and 5.x databases.

PDO_MYSQL will take advantage of native prepared statement support present in MySQL 4.1 and higher. If you're using an older version of the mysql client libraries, PDO will emulate them for you. 


eAccelerator

eAccelerator is a free open-source PHP accelerator & optimizer. It increases the performance of PHP scripts by caching them in their compiled state, so that the overhead of compiling is almost completely eliminated. It also optimizes scripts to speed up their execution. eAccelerator typically reduces server load and increases the speed of your PHP code by 1-10 times.

# tar jxvf eaccelerator-0.9.6.1.tar.bz2
# cd eaccelerator-0.9.6.1
# /usr/local/php/bin/phpize
# ./configure \
  --enable-eaccelerator=shared \
  --with-php-config=/usr/local/php/bin/php-config
# make
# make install

# vim /usr/local/php/etc/php.ini

添加如下内容：
  extension="eaccelerator.so"
  eaccelerator.shm_size="16"
  eaccelerator.cache_dir="/tmp/eaccelerator"
  eaccelerator.enable="1"
  eaccelerator.optimizer="1"
  eaccelerator.check_mtime="1"
  eaccelerator.debug="0"
  eaccelerator.filter=""
  eaccelerator.shm_max="0"
  eaccelerator.shm_ttl="0"
  eaccelerator.shm_prune_period="0"
  eaccelerator.shm_only="0"

# mkdir /tmp/eaccelerator
# chmod 0777 /tmp/eaccelerator


Configuration Options
---------------------

eaccelerator.shm_size
    The amount of shared memory (in megabytes) that eAccelerator will use.
    "0" means OS default. Default value is "0".

eaccelerator.cache_dir
    The directory that is used for disk cache. eAccelerator stores precompiled
    code, session data, content and user entries  here. The same data  can  be
    stored in shared memory also (for more quick access). Default value is
    "/tmp/eaccelerator".

eaccelerator.enable
    Enables or disables eAccelerator. Should be "1" for enabling  or  "0"  for
    disabling. Default value is "1".

eaccelerator.optimizer
    Enables or disables internal peephole optimizer which may  speed  up  code
    execution. Should be "1" for enabling or "0" for disabling. Default  value
    is "1".

eaccelerator.debug
    Enables or disables debug logging. Should be "1" for enabling or  "0"  for
    disabling. Default value is "0".

eaccelerator.check_mtime
    Enables or disables PHP file modification checking .  Should  be  "1"  for
    enabling or "0" for disabling. You should set it to "1"  if  you  want  to
    recompile PHP files after modification. Default value is "1".
    
eaccelerator.filter
    Determine which PHP files must be cached. You may specify  the  number  of
    patterns (for example "*.php *.phtml") which specifies to cache or not  to
    cache. If pattern starts with the character "!", it means to ignore  files
    which are matched by the following pattern. Default value is "" that means 
    all PHP scripts will be cached.

eaccelerator.shm_max
    Disables putting large values into shared memory by " eaccelerator_put() "
    function. It indicates the largest allowed size in bytes (10240, 10K, 1M). 
    The "0" disables the limit. Default value is "0".

eaccelerator.shm_ttl
    When eaccelerator fails to get shared memory for new script it removes all
    scripts which were not accessed  at  last "shm_ttl"  seconds  from  shared
    memory. Default value is "0" that means -  don't  remove  any  files  from
    shared memory.

eaccelerator.shm_prune_period
    When eaccelerator fails to get shared memory for new script  it  tryes  to
    remove  old  script   if   the   previous   try   was   made   more   then
    "shm_prune_period" seconds ago. Default value is "0" that  means  -  don't
    try to remove any files from shared memory.

eaccelerator.shm_only
    Enables or disables caching of compiled scripts on disk. It has  no  effect
    on session data and content caching. Default value is "0" that means -  use
    disk and shared memory for caching.

eaccelerator.allowed_admin_path
    The script paths that are allowed to get admin information and do admin 
    controls
    








http://www.a.com
http://www.b.org/

http://www.a.com/bbs

http://www.a.com/forum


URL: http://www.a.com/admin.php?a=3



rewrite
rewrite



The Rewrite Module

www.magedu.com/bbs  论坛
www.magedu.com/forum  论坛

page:
图片地址引用：http://172.16.100.4/images/a.jpg
172.16.100.5

http://www.magedu.com/attatch.php?value=111223



http://www.magedu.com/111222/attatch

last


rewrite ^/(attatch)\.php\?value=(.*)$ /$2/$1 break;
rewrite
rewrite
rewrite











SEO


URL

rewrite


A lot of sites undergo changes, and in some cases complete rewriting. In most cases the earlier contents URLs would have changed, leading to loss of SEO and, of course, inconvenience for older clients. This recipe will help you write simple rewrites so that you can ensure that your new site has all the redirect working.

rewrite指令的语法：
s@\(patt\)ern@\1@


rewrite regex replacement flag

rewrite ^/images/(.*\.jpg)$  /images2/$1 break;
rewrite ^/abc/.*$ /$1/abc/ last

location / {
rewrite ^/images/(.*\.jpg)$  /images2/$1 break;
rewrite ^/abc/.*$ /$1/abc/ last
}

location /images/ {
rewrite ^/images/(.*\.jpg)$  /images2/$1 break;

}

location /abc/ {
rewrite ^/abc/(.*)$ /$1/abc/ last
}

/abc/hello.html --> /hello.html/abc/




http://172.16.100.1/images2/logo.jpg


location / {
  rewrite ^/images/.*\.jpg$ /images/b.jpg break;
}

http://172.16.100.1/images/b.jpg

Flags can be any of the following:

last - completes processing of current rewrite directives and restarts the process (including rewriting) with a search for a match on the URI from all available locations.
break - completes processing of current rewrite directives and non-rewrite processing continues within the current location block only.
redirect - returns temporary redirect with code 302; it is used if the substituting line begins with http://
permanent - returns permanent redirect with code 301


rewrite "^/test/(.*\.jpg)$" "/test/repire.jpg" break;

rewrite "




set指令
语法：set variable value
应用环境: server, location, if

为变量设定值；可以是自定义的变量；


一、设置一个简单的URL重写：
比如，某网站原有的论坛访问路径为/forum/，但后来根据要求需要更改为/bbs，于是，就可以通过下面的方法实现：

rewrite ^/forum/?$ /bbs/ permanent;

http://172.16.100.1/forum/


1、if指令：
语法: if (condition) { ... }
应用环境: server, location

条件:

1、变量名; false values are: empty string ("", or any string starting with "0";)
2、对于变量进行的比较表达式，可使用=或!=进行测试;
3、正则表达式的模式匹配:
~  区分大小的模式匹配
~* 不区分字母大小写的模式匹配
!~ 和 !~* 分别对上面的两种测试取反
4、测试文件是否存在-f或!-f
5、测试目录是否存在-d或!-d
6、测试目录、文件或链接文件的存在性-e或!-e
7、检查一个文件的执行权限-x或!-x

在正则表达式中，可以使用圆括号标记匹配到的字符串，并可以分别使用$1,$2,...,$9进行引用；

例如：
判断用户的浏览器类型：
if ($http_user_agent ~* MSIE) {
  rewrite  ^(.*)$  /msie/$1  break;
}

wap.magedu.com

if ($http_user_agent ~* opera) {
  rewrite  ^(.*)$  /opera/$1  break;
}

如果用户请求的页面不存在，实现自定义跳转：

if (!-f $request_filename) {
      rewrite ^(/.*)$ /rewrite.html permanent;
}



实现域名跳转
server
{
listen 80;
server_name jump.magedu.com;
index index.html index.php;
root /www/htdocs;
rewrite ^/ http://www.magedu.com/;
}

实现域名镜像
server
{
listen 80;
server_name mirror.magedu.com;
index index.html index.php;
root /www/htdocs;
rewrite ^/(.*)$ http://www.magedu.com/$1 last;
}

简单的防盗链配置：
location ~* \.(gif|jpg|png|swf|flv)$ {
  valid_referers none blocked www.magedu.com;
  if ($invalid_referer) {
    rewrite ^/ http://www.magedu.com/403.html;
    # return 404
  }
}
第一行：gif|jpg|png|swf|flv
表示对gif、jpg、png、swf、flv后缀的文件实行防盗链
第二行：www.magedu.com
表示对www.magedu.com这个来路进行判断if{}里面内容的意思是，如果来路不是指定来路就跳转到错误页面，当然直接返回404也是可以的。

if (!-e $request_filename) {
      rewrite ^/user/([0-9]+)/?$ /view.php?go=user_$1 last;
      rewrite ^/component/id/([0-9]+)/?$ /page.php?pageid=$1 last;
      rewrite ^/component/([^/]+)/?$ /page.php?pagealias=$1 last;
      rewrite ^/category\_([0-9]+)\.htm$ http://$host/category/$1/ permanent;
      rewrite ^/showday\_([0-9]+)\_([0-9]+)\_([0-9]+)\.htm$ http://$host/date/$1/$2/$3/ permanent;
      showday_1_2_3.htm $host/date/1/2/3/
}



server {
  listen 80 default;
  server_name *.mysite.com;
  rewrite ^ http://mysite.com$request_uri permanent;
}




常用的变量：

$arg_PARAMETER        This variable contains the value of the GET request variable PARAMETER if present in the query string.
$args                 This variable contains the query string in the URL, for example foo=123&bar=blahblah if the URL is http://example1. com/? foo=123&bar=blahblah
$binary_remote_addr   The address of the client in binary form.
$body_bytes_sent      The bytes of the body sent.
$content_length       This variable is equal to line Content-Length in the header of request.
$content_type         This variable is equal to line Content-Type in the header of request.

$document_root        This variable is equal to the value of directive root for the current request.
$document_uri         The same as $uri.
$host                 This variable contains the value of the 'Host' value in the request header, or the name of the server processing if the 'Host' value is not available.
$http_HEADER          The value of the HTTP header HEADER when converted to lowercase and with "dashes" converted to "underscores", for example, $http_user_agent, $http_referer.
$is_args              Evaluates to "?" if $args is set, returns "" otherwise.
$request_uri          This variable is equal to the *original* request URI as received from the client including the args. It cannot be modified. Look at $uri for the post-rewrite/altered URI. Does not include host name. Example: "/foo/bar.php?arg=baz".
$scheme               The HTTP scheme (that is http, https). Evaluated only on demand, for example: rewrite ^(.+)$ $scheme://example.com$1 redirect;
$server_addr          This variable contains the server address. It is advisable to indicate addresses correctly in the listen directive and use the bind parameter so that a system call is not made every time this variable is accessed.
$server_name          The name of the server.
$server_port          This variable is equal to the port of the server, to which the request arrived.
$server_protocol      This variable is equal to the protocol of request, usually this is HTTP/1.0 or HTTP/1.1.

$uri                  This variable is equal to current URI in the request (without arguments, those are in $args.) It can differ from $request_uri which is what is sent by the browser. Examples of how it can be modified are internal redirects, or with the use of index. Does not include host name. Example: "/foo/bar.html"




HTTP Headers
HTTP_USER_AGENT
HTTP_REFERER
HTTP_COOKIE
HTTP_FORWARDED
HTTP_HOST
HTTP_PROXY_CONNECTION
HTTP_ACCEPT





Enabling a log file cache：

http {
...
open_log_file_cache max=1000 inactive=20s min_uses=2 valid=1m;
..


















Simple Load Balancing 

http {
  upstream myproject {
    server 172.16.100.11:80 weight=3;
    server 172.16.100.12:80;
  }
 
  server {
    listen 80;
    server_name www.a.com;
    location / {
      proxy_pass http://myproject;
    }
  }
}


















location / {
  proxy_pass        http://10.1.1.2;
  proxy_set_header  X-Real-IP  $remote_addr;
}











upstream backend  {
  server backend1.example.com weight=5;
  server backend2.example.com:8080;
}
 
server {
  location / {
    proxy_pass  http://backend;
  }
}

upstream myhttpd  {
  server 10.1.1.2:80;
  server 10.1.1.2:8080;
}

server {
  location / {
    proxy_pass  http://myhttpd;
  }



location /nginx_status {
  # copied from http://blog.kovyrin.net/2006/04/29/monitoring-nginx-with-rrdtool/
  stub_status on;
  access_log   off;
  allow SOME.IP.ADD.RESS;
  deny all;
}

active connections -- number of all open connections including connections to backends 

server accepts handled requests -- nginx accepted 16630948 connections, handled 16630948 connections (no one was closed just it was accepted), and handles 31070465 requests (1.8 requests per connection) 

reading -- nginx reads request header 

writing -- nginx reads request body, processes request, or writes response to a client 

waiting -- keep-alive connections, actually it is active - (reading + writing)


memcached

Memcached is an in-memory key-value store for small chunks of arbitrary data (strings, objects) from results of database calls, API calls, or page rendering.

Memcached is simple yet powerful. Its simple design promotes quick deployment, ease of development, and solves many problems facing large data caches.












http {
  proxy_cache_path /var/www/cache levels=1:2 keys_zone=mycache:20m
  max_size=2048m inactive=60m;
  proxy_temp_path /var/www/cache/tmp;
  ...
  server {
    listen 80;
    server_name magedu.com;
    access_log /var/log/magedu.com/log/access.log;
    error_log /var/log/magedu.com/log/error.log debug;
    #set your default location
    location / {
      proxy_pass http://172.16.100.6/;
      proxy_cache mycache;
      proxy_cache_valid 200 302 60m;
      proxy_cache_valid 404 1m;
    }
  }
}



配置：

1、设定错误日志格式及级别：

http {
log_format combined '$remote_addr - $remote_user [$time_local] '
        '"$request" $status $body_bytes_sent '
        '"$http_referer" "$http_user_agent"';
access_log /var/log/nginx/access.log combined;
error_log /var/log/nginx/error.log crit;
...
}

2、记录类似apache格式的日志：
log_format main '$remote_addr - $remote_user [$time_local] '
        '"$request" $status $body_bytes_sent "$http_referer" '
        '"$http_user_agent" "$http_x_forwarded_for"';
access_log /var/log/nginx/access.log main;

3、启用日志缓存：

http {
  ...
  open_log_file_cache max=1000 inactive=20s min_uses=2 valid=1m;
  ...
}

1,1


Max        Maximal number of descriptors in the cache, with overflow Least Recently Used removed (LRU)
Inactive   Sets the time after which descriptor without hits during this time are removed; default is 10 seconds
min_uses   Sets the minimum number of file usage within the time specified in parameter inactive, after which the file descriptor will be put in the cache; default is 1
Valid      Sets the time until it will be checked if file still exists under same name; default is 60 seconds
Off        Disables the cache




设定限速：

1、为某个特定路径限速：
server {
    server_name www.magedu.com;

    location /downloads/ {
        limit_rate 20k;
        root /web/downloads/;
    }
    ..
}

2、限制搜索引擎的bot速度：
if ($http_user_agent ~ Google|Yahoo|MSN|baidu) {
    limit_rate 20k;
}







The X-Forwarded-For (XFF) HTTP header field is a de facto standard for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. This is an HTTP request header which was introduced by the Squid caching proxy server's developers. An effort has been started at IETF for standardizing the Forwarded-For HTTP header.








设定反向代理：

简单示例：
location / {
  proxy_pass        http://www.internal.com:8080;
  proxy_set_header  X-Real-IP  $remote_addr;
}

X-Real-IP: 192.168.0.1



www.magedu.com

http://www.magedu.com


proxy_pass
  语法：proxy_pass URL;
  This directive sets the address of the proxied server and the URI to which location will be mapped. Address may be given as hostname or address and port. 例如：
    proxy_pass http://localhost:8000/uri/;


  By default, the Host header from the request is not forwarded, but is set based on the proxy_pass statement. To forward the requested Host header, it is necessary to use:

    proxy_set_header Host $host;

proxy_read_timeout
  语法：proxy_read_timeout time;
  This directive sets the read timeout for the response of the proxied server. It determines how long nginx will wait to get the response to a request. The timeout is established not for entire response, but only between two operations of reading.

proxy_send_timeout
  语法：roxy_send_timeout time;
  This directive assigns timeout with the transfer of request to the upstream server. Timeout is established not on entire transfer of request, but only between two write operations. If after this time the upstream server will not take new data, then nginx is shutdown the connection.



nginx和后端http服务器之间的连接是通过http/1.0协议进行的，因此，每连接是单独建立的；但Nginx和客户端的browser之间的会话是基于http/1.1，因此可以实现keep-alive的功能。此外，在响应用户之前，nginx把每一个用户的会话缓存至本地。


其它常用指令：

proxy_buffers
  语法: proxy_buffers the_number is_size;
  This directive sets the number and the size of buffers, into which will be read the answer, obtained from the proxied server. By default, the size of one buffer is equal to the size of page. 
  例如：
  proxy_buffers 32 4k；

proxy_set_header
  语法：proxy_set_header header value;
  This directive allows to redefine and to add some request header lines which will be transferred to the proxied server.

  例如：
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

proxy_connect_timeout
  语法：proxy_connect_timeout time;
  This directive assigns a timeout for the connection to the upstream server. It is necessary to keep in mind that this time out cannot be more than 75 seconds.

proxy_no_cache
  语法：proxy_no_cache variable1 variable2 ...;
  定义不进行缓存的情形，例如：
  proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;
  proxy_no_cache $http_pragma $http_authorization;
  


为反向代理启用缓存功能：

http {
    proxy_cache_path  /data/nginx/cache  levels=1:2    keys_zone=STATIC:10m
                                         inactive=24h  max_size=1g;
    server {
        location / {
            proxy_pass             http://1.2.3.4;
            proxy_set_header       Host $host;
            proxy_cache            STATIC;
            proxy_cache_valid      200  1d;
            proxy_cache_use_stale  error timeout invalid_header updating
                                   http_500 http_502 http_503 http_504;
        }
    }
}



proxy_cache_path
  语法：proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size];
  This directive sets the cache path and other cache parameters. Cached data is stored in files. An MD5 hash of the proxied URL is used as the key for the cache entry, and is also used as the filename in the cache path for the response contents and metadata. 
  
  The levels parameter sets the number of subdirectory levels in cache. You may use any combination of 1 and 2 in the level formats: X, X:X, or X:X:X e.g.: "2", "2:2", "1:1:2". There can be at most 3 levels.
  
  All active keys and metadata is stored in shared memory. Zone name and the size of the zone is defined via the keys_zone parameter.
  
  If cached data is not requested for time defined by the inactive parameter, than that data is removed from the cache. The inactive parameter defaults to 10 minutes (10m).
  
  
proxy_cache
  语法：proxy_cache zone_name;
  This directive sets name of zone for caching. The same zone can be used in multiple places.
  
  The following response headers flag a response as uncacheable unless they are ignored:
    Set-Cookie
    Cache-Control containing "no-cache", "no-store", "private", or a "max-age" with a non-numeric or 0 value
    Expires with a time in the past
    X-Accel-Expires: 0
  
proxy_cache_valid
  语法: proxy_cache_valid reply_code [reply_code ...] time;
  设定对于不同类别应答的缓存时间. Example:
      proxy_cache_valid  200 302  10m;
      proxy_cache_valid  404      1m;
  Also it is possible to cache any replies with parameter "any":
    proxy_cache_valid  200 302 10m;
    proxy_cache_valid  301 1h;
    proxy_cache_valid  any 1m;






反向代理多台服务器实现负载均衡：

upstream backend {
  server www1.magedu.com weight=5;
  server www2.magedu.com max_fails=3 fail_timeout=30s;
  server www3.magedu.com;
}
server {
  listen 80;
  server_name example1.com;
  access_log /var/log/magedu.com/access.log;
  error_log /var/log/magedu.com/error.log debug;
  #set your default location
  location / {
    include proxy.conf;
    proxy_pass http://backend;
  }
}


172.16.0.1
127.0.0.1:8080


server
  语法：server name [parameters]
  其中的name可以是FQDN，主机地址，端口或unix套接字；如果FQDN解析的结果为多个地址，则每个地址都会被用到；
  
  weight = NUMBER - 设定权重，默认为1.
  max_fails = NUMBER - 在fail_timeout指令设定的时间内发往此server的不成功的请求次数，达到此数目后，此服务器将变为不可操作状态；默认值为1；设定为0值则禁用此功能；
  fail_timeout = TIME - 默认为10秒；
  down - marks server as permanently offline, to be used with the directive ip_hash.
  backup - (0.6.7 or later) only uses this server if the non-backup servers are all down or busy (cannot be used with the directive ip_hash)



upstream
  语法：upstream name { ... }
  声明一组可以被proxy_pass和fastcgi_pass引用的服务器；这些服务器可以使用不同的端口，并且也可以使用Unix Socket；也可以为服务器指定不同的权重；例如：
  
  upstream backend {
    server backend1.magedu.com weight=5 down backup;
    server 127.0.0.1:8080     max_fails=3  fail_timeout=30s;
    server unix:/tmp/backend3;
  }






LNMMP = 




安装配置第三方模块，实现upstream中对后端http server的健康状态检测：

模块下载地址：https://github.com/cep21/healthcheck_nginx_upstreams；模块名称：ngx_http_healthcheck_module

安装配置方法：
1、首先解压healcheck模块到某路径下，这里假设为/tmp/healthcheck_nginx_upstreams

2、对nginx打补丁

首先解压nginx，并进入nginx源码目录：
# tar xf nginx-1.0.11.tar.gz
# cd nginx-1.0.11
# patch -p1 < /tmp/healthcheck_nginx_upstreams/nginx.patch

而后编译nginx，在执行configure时添加类似下面的选项：
--add-module=/tmp/healthcheck_nginx_upstreams

所以，这里就使用如下命令：
# ./configure \
  --prefix=/usr \
  --sbin-path=/usr/sbin/nginx \
  --conf-path=/etc/nginx/nginx.conf \
  --error-log-path=/var/log/nginx/error.log \
  --http-log-path=/var/log/nginx/access.log \
  --pid-path=/var/run/nginx/nginx.pid  \
  --lock-path=/var/lock/nginx.lock \
  --user=nginx \
  --group=nginx \
  --with-http_ssl_module \
  --with-http_flv_module \
  --with-http_stub_status_module \
  --with-http_gzip_static_module \
  --http-client-body-temp-path=/var/tmp/nginx/client/ \
  --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
  --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
  --with-pcre \
  --add-module=/tmp/healthcheck_nginx_upstreams
# make && make install

ngx_http_healthcheck_module模块的使用方法：

1、此模块支持的指令有：
healthcheck_enabled
  启用此模块
  
healthcheck_delay
  对同一台后端服务器两次检测之间的时间间隔，单位毫秒，默认为1000；
  
healthcheck_timeout
  进行一次健康检测的超时时间，单位为毫秒，默认值2000；

healthcheck_failcount
  对一台后端服务器检测成功或失败多少次之后方才确定其为成功或失败，并实现启用或禁用此服务器；

healthcheck_send
  为了检测后端服务器的健康状态所发送的检测请求；如：healthcheck_send "GET /health HTTP/1.0" 'Host: www.magedu.com';
  
healthcheck_expected
  期望从后端服务器收到的响应内容；如果未设置，则表示从后端服务器收到200状态码即为正确；
  
healthcheck_buffer
  健康状态检查所使用的buffer空间大小；

healthcheck_status
  通过类似stub_status的方式输出检测信息，使用方法如下：
  location /stat {
      healthcheck_status;
    }

一个例子：


http {

  upstream backend {
    server 127.0.0.1:8080;
    server 172.16.0.1:80;
    healthcheck_enabled;
    healthcheck_delay 1000;
    healthcheck_timeout 1000;
    healthcheck_failcount 3;
    healthcheck_send "GET /.health HTTP/1.0";
    # Optional supervisord module support
    #supervisord none;
    #supervisord_inherit_backend_status;
  }

  server {
    listen 80;

    location / {
      proxy_set_header Host $http_host;
      proxy_pass http://backend;
      proxy_connect_timeout 3;
    }
    location /stat {
      healthcheck_status;
    }
  }
}












Nginx整合memcached:

server {
        listen       80;
        server_name  www.magedu.com;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
                set $memcached_key $uri;
                memcached_pass     127.0.0.1:11211;
                default_type       text/html;
                error_page         404 @fallback;
        }

        location @fallback {
                proxy_pass http://172.16.0.1;
        }
}






LAMMP平台
LNAMMP平台
nagios监控windows主机和Linux主机


MySQL服务常用参数及其意义



sed, awk, grep








upstream memcached {
    server    127.0.0.1:11211;
    keepalive 1024;
}
 
upstream backend {
    server    127.0.0.1:9000;
}
 
server {
    listen          80;
    server_name     live.framework.com;
 
    access_log      /var/log/nginx/framework.access.log;
    error_log       /var/log/nginx/framework.errors.log notice;
 
    root            /home/framework;
 
    location / {
        try_files $uri @missing;
    }
 
    location @missing {
        rewrite ^(.*[^/])$ $1/ permanent; # Add a trailing slash if none exist.
        rewrite ^ /index.php last;
    }
 
    # Forbid the system dir, but allow media files.
    location ~* ^/system/.+\.(jpg|png|gif|css|js|swf|flv|ico)$ {
        expires max;
        tcp_nodelay off;
        tcp_nopush on;
    }
 
    location ~ /system/ {
        rewrite ^ /index.php last;
    }
 
    # Check cache and use PHP as fallback.
    location ~* \.php$ {
        default_type text/html;
        charset      utf-8;
 
        if ($request_method = GET) {
            set $memcached_key fw53$request_uri;
 
            memcached_pass     memcached;
            error_page         404 502 = @nocache;
        }
 
        if ($request_method != GET) {
            fastcgi_pass backend;
        }
    }
 
    location @nocache {
        fastcgi_pass backend;
    }
}













